<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAC Skill Gap Analyzer - Complete System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .main-header {
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .main-title {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(135deg, #00d4ff 0%, #7b2ff7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        .main-subtitle {
            color: #cccccc;
            font-size: clamp(0.875rem, 2vw, 1.1rem);
        }
        
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 0.5rem;
            color: white;
            cursor: pointer;
            font-size: clamp(0.875rem, 1.5vw, 1rem);
            transition: all 0.3s ease;
        }
        
        .tab-button:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: rgba(0, 212, 255, 0.6);
            transform: translateY(-2px);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
            border-color: #00d4ff;
            box-shadow: 0 0.3rem 1.5rem rgba(0, 212, 255, 0.5);
        }
        
        .view-container {
            display: none;
            padding: 1rem;
        }
        
        .view-container.active {
            display: block;
        }
        
        /* Discovery Matrix Styles */
        .matrix-container {
            width: 100%;
            overflow: auto;
            padding: 1rem;
        }
        
        .matrix-subtitle {
            color: #d1d5db;
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: clamp(0.875rem, 1.5vw, 1rem);
        }
        
        #matrix {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .connection {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .label {
            font-size: clamp(0.625rem, 1vw, 0.75rem);
            font-weight: bold;
        }
        
        /* Feedback Loop Styles */
        .legend {
            display: flex;
            justify-content: center;
            gap: clamp(1rem, 3vw, 2rem);
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 0.625rem;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            font-size: clamp(0.75rem, 1.5vw, 0.9rem);
        }
        
        .legend-line {
            width: clamp(2rem, 5vw, 3.125rem);
            height: 0.25rem;
            position: relative;
        }
        
        .legend-line.positive {
            background: linear-gradient(90deg, #00ff88, #00cc66);
        }
        
        .legend-line.negative {
            background: linear-gradient(90deg, #ff3366, #cc0044);
        }
        
        .legend-line::after {
            content: '';
            position: absolute;
            right: -0.5rem;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 0.75rem solid currentColor;
            border-top: 0.5rem solid transparent;
            border-bottom: 0.5rem solid transparent;
        }
        
        .legend-line.positive::after {
            color: #00cc66;
        }
        
        .legend-line.negative::after {
            color: #cc0044;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.9375rem;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: auto;
            height: 75vh;
            min-height: 37.5rem;
        }
        
        #flowchart {
            width: 100%;
            height: 100%;
            min-height: 50rem;
            position: relative;
        }
        
        .flow-node {
            position: absolute;
            padding: 0.9375rem 1.25rem;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.25), rgba(123, 47, 247, 0.25));
            border: 2px solid rgba(0, 212, 255, 0.6);
            border-radius: 0.625rem;
            cursor: grab;
            transition: all 0.3s ease;
            box-shadow: 0 0.25rem 1.25rem rgba(0, 212, 255, 0.3);
            backdrop-filter: blur(5px);
            text-align: center;
            min-width: 9.375rem;
            user-select: none;
            font-size: clamp(0.75rem, 1.5vw, 0.9rem);
        }
        
        .flow-node:active {
            cursor: grabbing;
        }
        
        .flow-node:hover {
            transform: scale(1.05);
            border-color: rgba(0, 212, 255, 0.9);
            box-shadow: 0 0.375rem 1.875rem rgba(0, 212, 255, 0.5);
            z-index: 10;
        }
        
        .flow-node.active {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.4), rgba(123, 47, 247, 0.4));
            border-color: #00d4ff;
            box-shadow: 0 0.5rem 2.1875rem rgba(0, 212, 255, 0.7);
            z-index: 100 !important;
        }
        
        .flow-node.faded {
            opacity: 0.2;
            filter: grayscale(0.5);
        }
        
        .flow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .flow-connection {
            fill: none;
            stroke-width: 3;
            transition: all 0.3s ease;
        }
        
        .flow-connection.positive {
            stroke: rgba(0, 255, 136, 0.3);
        }
        
        .flow-connection.negative {
            stroke: rgba(255, 51, 102, 0.3);
        }
        
        .flow-connection.highlight {
            stroke-width: 5;
        }
        
        .flow-connection.highlight.positive {
            stroke: #00ff88;
            filter: drop-shadow(0 0 0.625rem #00ff88);
        }
        
        .flow-connection.highlight.negative {
            stroke: #ff3366;
            filter: drop-shadow(0 0 0.625rem #ff3366);
        }
        
        .flow-connection.faded {
            opacity: 0.1;
        }
        
        .pulse {
            r: 6;
            transition: opacity 0.3s ease;
        }
        
        .pulse.positive {
            fill: #00ff88;
            filter: drop-shadow(0 0 0.375rem #00ff88);
        }
        
        .pulse.negative {
            fill: #ff3366;
            filter: drop-shadow(0 0 0.375rem #ff3366);
        }
        
        .pulse.hidden {
            opacity: 0;
        }
        
        .arrow {
            transition: all 0.3s ease;
        }
        
        .arrow.positive {
            fill: rgba(0, 255, 136, 0.3);
        }
        
        .arrow.negative {
            fill: rgba(255, 51, 102, 0.3);
        }
        
        .arrow.highlight.positive {
            fill: #00ff88;
            filter: drop-shadow(0 0 0.5rem #00ff88);
        }
        
        .arrow.highlight.negative {
            fill: #ff3366;
            filter: drop-shadow(0 0 0.5rem #ff3366);
        }
        
        .arrow.faded {
            opacity: 0.1;
        }
        
        .controls {
            text-align: center;
            margin-top: 1.25rem;
            padding: 0.9375rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 0.625rem;
        }
        
        .control-button {
            padding: 0.75rem 1.5rem;
            margin: 0.5rem;
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
            border: none;
            border-radius: 0.5rem;
            color: white;
            cursor: pointer;
            font-size: clamp(0.875rem, 1.5vw, 1rem);
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0.3125rem 1.5625rem rgba(0, 212, 255, 0.5);
        }
        
        @media (max-width: 768px) {
            .canvas-container {
                height: 60vh;
                min-height: 25rem;
            }
            
            #flowchart {
                min-height: 37.5rem;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <h1 class="main-title">SNAC Skill Gap Analyzer</h1>
        <p class="main-subtitle">Complete System Visualization</p>
    </header>

    <nav class="nav-tabs">
        <button class="tab-button active" id="matrixTab">Discovery Matrix</button>
        <button class="tab-button" id="feedbackTab">Feedback Loops</button>
    </nav>

    <!-- Discovery Matrix View -->
    <div id="matrix-view" class="view-container active">
        <div class="matrix-container">
            <p class="matrix-subtitle">Circular/Radial Layout - Organized by Stakeholder Connections</p>
            <svg id="matrix" width="1400" height="900" viewBox="0 0 1400 900" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
    </div>

    <!-- Feedback Loops View -->
    <div id="feedback-view" class="view-container">
        <div class="legend">
            <div class="legend-item">
                <div class="legend-line positive"></div>
                <span>Positive Feedback Loop</span>
            </div>
            <div class="legend-item">
                <div class="legend-line negative"></div>
                <span>Negative Feedback Loop</span>
            </div>
        </div>

        <div class="canvas-container">
            <div id="flowchart">
                <svg id="connections" class="flow-svg"></svg>
            </div>
        </div>

        <div class="controls">
            <button class="control-button" id="resetBtn">Reset View</button>
            <button class="control-button" id="highlightBtn">Highlight All Loops</button>
        </div>
    </div>

    <script>
        // Global variables
        let feedbackInitialized = false;
        let selectedNode = null;
        
        // ==================== VIEW SWITCHING ====================
        document.getElementById('matrixTab').addEventListener('click', function() {
            document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
            document.getElementById('matrix-view').classList.add('active');
            this.classList.add('active');
        });

        document.getElementById('feedbackTab').addEventListener('click', function() {
            document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
            document.getElementById('feedback-view').classList.add('active');
            this.classList.add('active');
            
            if (!feedbackInitialized) {
                initFeedbackView();
                feedbackInitialized = true;
            }
        });

        // ==================== DISCOVERY MATRIX CODE ====================
        const centerX = 700;
        const centerY = 450;
        const radius = 420;

        const stakeholders = [
            { id: 'S1', label: 'Job Seekers/Employees' },
            { id: 'S2', label: 'Employers/Organizations/HR' },
            { id: 'S3', label: 'Training Providers' },
            { id: 'S4', label: 'Platform Admins' },
            { id: 'S5', label: 'Government/Policy Makers' },
            { id: 'S6', label: 'Data Providers/Accreditation Bodies' }
        ];

        const needs = [
            { id: 'N6.1', label: 'Platform access to validate standards' },
            { id: 'N6.2', label: 'Data to evaluate training quality' },
            { id: 'N6.3', label: 'Partnership for standardized frameworks' },
            { id: 'N5.1', label: 'Workforce statistics and skill gap trends' },
            { id: 'N5.2', label: 'Insights for skill development programs' },
            { id: 'N5.3', label: 'Alignment with national missions' },
            { id: 'N5.4', label: 'Data for future job market policy' },
            { id: 'N4.1', label: 'System reliability and uptime' },
            { id: 'N4.2', label: 'User engagement and retention' },
            { id: 'N4.3', label: 'Data security and privacy compliance' },
            { id: 'N3.4', label: 'Course module recommendations' },
            { id: 'N3.3', label: 'Course effectiveness feedback' },
            { id: 'N3.2', label: 'Emerging skill demands from industry' },
            { id: 'N2.3', label: 'Tools to identify skill shortages' },
            { id: 'N2.2', label: 'Workforce visibility' },
            { id: 'N2.1', label: 'Accurate assessment of candidate competencies' },
            { id: 'N1.3', label: 'Quick gap identification' },
            { id: 'N1.2', label: 'Personalized recommendations' },
            { id: 'N1.1', label: 'Accurate skill assessment' }
        ];

        const alterables = [
            { id: 'A1', label: 'Business Model & Pricing Strategy' },
            { id: 'A2', label: 'Skill Taxonomy Framework' },
            { id: 'A3', label: 'Data Sources & Partnerships' },
            { id: 'A4', label: 'Platform Architecture' },
            { id: 'A5', label: 'Recommendation Algorithm Complexity' },
            { id: 'A6', label: 'Assessment Methodology' },
            { id: 'A7', label: 'Geographic & Industry Scope' },
            { id: 'A8', label: 'User Interface & Experience design' },
            { id: 'A9', label: 'Data Analytics & Reporting Capabilities' },
            { id: 'A10', label: 'Integration & API Ecosystem' }
        ];

        const constraints = [
            { id: 'C1', label: 'Data Privacy & Regulatory Compliance' },
            { id: 'C2', label: 'Technical Infrastructure Limitations' },
            { id: 'C3', label: 'Budget & Financial Resources' },
            { id: 'C4', label: 'Data Quality & Availability' },
            { id: 'C5', label: 'Time-to-Market Pressure' },
            { id: 'C6', label: 'Algorithm Accuracy & Bias' },
            { id: 'C7', label: 'Stakeholder Adoption Barriers' },
            { id: 'C8', label: 'Market Competition' },
            { id: 'C9', label: 'Skill Taxonomy Standardization' },
            { id: 'C10', label: 'Network Effects Dependency' }
        ];

        const matrixConnections = [
            { from: 'S1', to: 'N1.1', type: 'S-N' },
            { from: 'S1', to: 'N1.2', type: 'S-N' },
            { from: 'S1', to: 'N1.3', type: 'S-N' },
            { from: 'S2', to: 'N2.1', type: 'S-N' },
            { from: 'S2', to: 'N2.2', type: 'S-N' },
            { from: 'S2', to: 'N2.3', type: 'S-N' },
            { from: 'S3', to: 'N3.2', type: 'S-N' },
            { from: 'S3', to: 'N3.3', type: 'S-N' },
            { from: 'S3', to: 'N3.4', type: 'S-N' },
            { from: 'S4', to: 'N4.1', type: 'S-N' },
            { from: 'S4', to: 'N4.2', type: 'S-N' },
            { from: 'S4', to: 'N4.3', type: 'S-N' },
            { from: 'S5', to: 'N5.1', type: 'S-N' },
            { from: 'S5', to: 'N5.2', type: 'S-N' },
            { from: 'S5', to: 'N5.3', type: 'S-N' },
            { from: 'S5', to: 'N5.4', type: 'S-N' },
            { from: 'S6', to: 'N6.1', type: 'S-N' },
            { from: 'S6', to: 'N6.2', type: 'S-N' },
            { from: 'S6', to: 'N6.3', type: 'S-N' },
            { from: 'N1.1', to: 'A6', type: 'N-A' },
            { from: 'N1.1', to: 'A2', type: 'N-A' },
            { from: 'N1.2', to: 'A5', type: 'N-A' },
            { from: 'N1.2', to: 'A3', type: 'N-A' },
            { from: 'N1.3', to: 'A5', type: 'N-A' },
            { from: 'N1.3', to: 'A10', type: 'N-A' },
            { from: 'N2.1', to: 'A6', type: 'N-A' },
            { from: 'N2.1', to: 'A9', type: 'N-A' },
            { from: 'N2.2', to: 'A7', type: 'N-A' },
            { from: 'N2.2', to: 'A9', type: 'N-A' },
            { from: 'N2.3', to: 'A3', type: 'N-A' },
            { from: 'N3.2', to: 'A9', type: 'N-A' },
            { from: 'N3.2', to: 'A10', type: 'N-A' },
            { from: 'N3.3', to: 'A3', type: 'N-A' },
            { from: 'N3.3', to: 'A7', type: 'N-A' },
            { from: 'N3.4', to: 'A9', type: 'N-A' },
            { from: 'N3.4', to: 'A10', type: 'N-A' },
            { from: 'N4.1', to: 'A4', type: 'N-A' },
            { from: 'N4.2', to: 'A8', type: 'N-A' },
            { from: 'N4.2', to: 'A1', type: 'N-A' },
            { from: 'N4.3', to: 'A4', type: 'N-A' },
            { from: 'N5.1', to: 'A9', type: 'N-A' },
            { from: 'N5.1', to: 'A7', type: 'N-A' },
            { from: 'N6.1', to: 'A2', type: 'N-A' },
            { from: 'N6.1', to: 'A10', type: 'N-A' },
            { from: 'A3', to: 'C1', type: 'A-C' },
            { from: 'A4', to: 'C1', type: 'A-C' },
            { from: 'A9', to: 'C1', type: 'A-C' },
            { from: 'A1', to: 'C2', type: 'A-C' },
            { from: 'A4', to: 'C2', type: 'A-C' },
            { from: 'A5', to: 'C2', type: 'A-C' },
            { from: 'A9', to: 'C2', type: 'A-C' },
            { from: 'A3', to: 'C3', type: 'A-C' },
            { from: 'A4', to: 'C3', type: 'A-C' },
            { from: 'A5', to: 'C3', type: 'A-C' },
            { from: 'A6', to: 'C3', type: 'A-C' },
            { from: 'A10', to: 'C3', type: 'A-C' },
            { from: 'A2', to: 'C4', type: 'A-C' },
            { from: 'A3', to: 'C4', type: 'A-C' },
            { from: 'A5', to: 'C4', type: 'A-C' },
            { from: 'A9', to: 'C4', type: 'A-C' },
            { from: 'A1', to: 'C5', type: 'A-C' },
            { from: 'A4', to: 'C5', type: 'A-C' },
            { from: 'A5', to: 'C5', type: 'A-C' },
            { from: 'A8', to: 'C5', type: 'A-C' },
            { from: 'A10', to: 'C5', type: 'A-C' },
            { from: 'A1', to: 'C6', type: 'A-C' },
            { from: 'A2', to: 'C6', type: 'A-C' },
            { from: 'A5', to: 'C6', type: 'A-C' },
            { from: 'A6', to: 'C7', type: 'A-C' },
            { from: 'A8', to: 'C7', type: 'A-C' },
            { from: 'A10', to: 'C7', type: 'A-C' },
            { from: 'A3', to: 'C8', type: 'A-C' },
            { from: 'A6', to: 'C8', type: 'A-C' },
            { from: 'A7', to: 'C8', type: 'A-C' },
            { from: 'A8', to: 'C8', type: 'A-C' },
            { from: 'A1', to: 'C9', type: 'A-C' },
            { from: 'A2', to: 'C9', type: 'A-C' },
            { from: 'A10', to: 'C9', type: 'A-C' },
            { from: 'A6', to: 'C10', type: 'A-C' },
            { from: 'A7', to: 'C10', type: 'A-C' },
            { from: 'A10', to: 'C10', type: 'A-C' }
        ];

        const categoryPositions = {
            S: { angle: -Math.PI / 2, color: '#3b82f6', title: 'Stakeholders' },
            N: { angle: 0, color: '#10b981', title: 'Needs' },
            A: { angle: Math.PI / 2, color: '#f59e0b', title: 'Alterables' },
            C: { angle: Math.PI, color: '#ef4444', title: 'Constraints' }
        };

        const alterableColors = {
            'A1': '#fef3c7', 'A2': '#fde68a', 'A3': '#fcd34d', 'A4': '#fbbf24',
            'A5': '#f59e0b', 'A6': '#f97316', 'A7': '#ea580c', 'A8': '#dc2626',
            'A9': '#b91c1c', 'A10': '#ff0040'
        };

        const constraintColors = {
            'C10': '#ff1493', 'C9': '#ff69b4', 'C8': '#ff85c1', 'C7': '#ffa0d0',
            'C6': '#d8a0e8', 'C5': '#c090e0', 'C4': '#a880d8', 'C3': '#9070d0',
            'C2': '#7860c8', 'C1': '#8b5cf6'
        };

        function getItemPosition(items, categoryAngle, itemIndex, category) {
            const itemCount = items.length;
            let spreadAngle = Math.PI / 4;
            if (category === 'S') spreadAngle = Math.PI / 2.5;
            else if (category === 'N') spreadAngle = Math.PI / 2.8;
            else if (category === 'A') spreadAngle = Math.PI / 2.2;
            else if (category === 'C') spreadAngle = Math.PI / 2.3;
            
            const startAngle = categoryAngle - spreadAngle / 2;
            const angleStep = spreadAngle / (itemCount - 1 || 1);
            const angle = itemCount === 1 ? categoryAngle : startAngle + itemIndex * angleStep;
            
            return {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        }

        function getCategoryCenter(category) {
            const pos = categoryPositions[category];
            return {
                x: centerX + (radius + 120) * Math.cos(pos.angle),
                y: centerY + (radius + 120) * Math.sin(pos.angle)
            };
        }

        function getNodeColor(item, category) {
            if (category === 'N') {
                if (item.id.startsWith('N1')) return '#065f46';
                if (item.id.startsWith('N2')) return '#6ee7b7';
                if (item.id.startsWith('N3')) return '#065f46';
                if (item.id.startsWith('N4')) return '#6ee7b7';
                if (item.id.startsWith('N5')) return '#065f46';
                if (item.id.startsWith('N6')) return '#6ee7b7';
            }
            return categoryPositions[category].color;
        }

        function isConnectedToSelected(itemId) {
            if (!selectedNode) return false;
            return matrixConnections.some(conn => 
                (conn.from === selectedNode && conn.to === itemId) ||
                (conn.to === selectedNode && conn.from === itemId)
            );
        }

        function renderMatrixConnections(svg) {
            const allItems = { S: stakeholders, N: needs, A: alterables, C: constraints };
            
            matrixConnections.forEach(conn => {
                const fromCategory = conn.from[0];
                const toCategory = conn.to[0];
                
                const fromItems = allItems[fromCategory];
                const toItems = allItems[toCategory];
                
                const fromIdx = fromItems.findIndex(item => item.id === conn.from);
                const toIdx = toItems.findIndex(item => item.id === conn.to);
                
                if (fromIdx === -1 || toIdx === -1) return;
                
                const fromPos = getItemPosition(fromItems, categoryPositions[fromCategory].angle, fromIdx, fromCategory);
                const toPos = getItemPosition(toItems, categoryPositions[toCategory].angle, toIdx, toCategory);
                
                let color = categoryPositions[fromCategory].color;
                if (conn.type === 'N-A') color = alterableColors[conn.to] || color;
                if (conn.type === 'A-C') color = constraintColors[conn.to] || color;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromPos.x);
                line.setAttribute('y1', fromPos.y);
                line.setAttribute('x2', toPos.x);
                line.setAttribute('y2', toPos.y);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '2.5');
                line.setAttribute('stroke-opacity', '0.7');
                line.classList.add('connection');
                line.dataset.from = conn.from;
                line.dataset.to = conn.to;
                
                line.addEventListener('mouseenter', () => {
                    line.setAttribute('stroke-width', '3.5');
                    line.setAttribute('stroke-opacity', '1');
                });
                
                line.addEventListener('mouseleave', () => {
                    updateMatrixOpacity();
                });
                
                svg.appendChild(line);
            });
        }

        function renderCategory(svg, items, category) {
            const catPos = categoryPositions[category];
            const center = getCategoryCenter(category);
            
            if (category === 'S' || category === 'A') {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', center.x - 100);
                rect.setAttribute('y', center.y - 30);
                rect.setAttribute('width', 200);
                rect.setAttribute('height', 60);
                rect.setAttribute('fill', catPos.color);
                rect.setAttribute('rx', 10);
                svg.appendChild(rect);
                
                const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text1.setAttribute('x', center.x);
                text1.setAttribute('y', center.y);
                text1.setAttribute('text-anchor', 'middle');
                text1.setAttribute('fill', 'white');
                text1.style.fontWeight = 'bold';
                text1.style.fontSize = '1.125rem';
                text1.textContent = catPos.title;
                svg.appendChild(text1);
                
                const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text2.setAttribute('x', center.x);
                text2.setAttribute('y', center.y + 15);
                text2.setAttribute('text-anchor', 'middle');
                text2.setAttribute('fill', 'white');
                text2.style.fontSize = '0.875rem';
                text2.style.fontWeight = '600';
                text2.textContent = `(${category})`;
                svg.appendChild(text2);
            }
            
            items.forEach((item, idx) => {
                const pos = getItemPosition(items, catPos.angle, idx, category);
                const nodeColor = getNodeColor(item, category);
                
                let labelX = pos.x;
                let labelY = pos.y + 25;
                let labelAnchor = "middle";
                
                if (category === 'S') {
                    labelY = pos.y - 15;
                } else if (category === 'N') {
                    labelX = pos.x + 18;
                    labelY = pos.y + 10;
                    labelAnchor = "start";
                } else if (category === 'A') {
                    if (['A1', 'A2', 'A3', 'A4'].includes(item.id)) {
                        labelX = pos.x + 18;
                        labelY = pos.y + 10;
                        labelAnchor = "start";
                    } else if (item.id === 'A5') {
                        labelX = pos.x + 18;
                        labelY = pos.y + 20;
                        labelAnchor = "start";
                    } else if (item.id === 'A6') {
                        labelX = pos.x - 18;
                        labelY = pos.y + 20;
                        labelAnchor = "end";
                    } else {
                        labelX = pos.x - 18;
                        labelY = pos.y + 10;
                        labelAnchor = "end";
                    }
                } else if (category === 'C') {
                    labelX = pos.x - 18;
                    labelY = pos.y + 10;
                    labelAnchor = "end";
                }
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', 8);
                circle.setAttribute('fill', nodeColor);
                circle.classList.add('node');
                circle.dataset.id = item.id;
                
                circle.addEventListener('click', () => {
                    selectedNode = selectedNode === item.id ? null : item.id;
                    updateMatrixOpacity();
                });
                
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', labelX);
                text.setAttribute('y', labelY);
                text.setAttribute('text-anchor', labelAnchor);
                text.setAttribute('fill', '#e5e7eb');
                text.classList.add('label');
                text.dataset.id = item.id;
                text.textContent = item.label;
                svg.appendChild(text);
            });
        }

        function updateMatrixOpacity() {
            document.querySelectorAll('.node, .label').forEach(el => {
                const id = el.dataset.id;
                const isConnected = isConnectedToSelected(id);
                const isSelected = selectedNode === id;
                
                if (selectedNode) {
                    el.style.opacity = (isSelected || isConnected) ? '1' : '0.3';
                    if (isSelected && el.classList.contains('node')) {
                        el.setAttribute('stroke', '#ffffff');
                        el.setAttribute('stroke-width', '3');
                    } else if (el.classList.contains('node')) {
                        el.setAttribute('stroke', 'none');
                        el.setAttribute('stroke-width', '0');
                    }
                } else {
                    el.style.opacity = '1';
                    if (el.classList.contains('node')) {
                        el.setAttribute('stroke', 'none');
                        el.setAttribute('stroke-width', '0');
                    }
                }
            });
            
            document.querySelectorAll('.connection').forEach(line => {
                const from = line.dataset.from;
                const to = line.dataset.to;
                const isConnected = selectedNode && (from === selectedNode || to === selectedNode);
                
                if (selectedNode) {
                    line.setAttribute('stroke-opacity', isConnected ? '1' : '0.2');
                    line.setAttribute('stroke-width', isConnected ? '3.5' : '2.5');
                } else {
                    line.setAttribute('stroke-opacity', '0.7');
                    line.setAttribute('stroke-width', '2.5');
                }
            });
        }

        function initMatrix() {
            const svg = document.getElementById('matrix');
            
            renderMatrixConnections(svg);
            renderCategory(svg, stakeholders, 'S');
            renderCategory(svg, needs, 'N');
            renderCategory(svg, alterables, 'A');
            renderCategory(svg, constraints, 'C');
            
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 95);
            outerCircle.setAttribute('fill', '#4b5563');
            outerCircle.setAttribute('stroke', '#6b7280');
            outerCircle.setAttribute('stroke-width', 4);
            outerCircle.setAttribute('opacity', 0.8);
            svg.appendChild(outerCircle);
            
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 80);
            innerCircle.setAttribute('fill', '#1f2937');
            innerCircle.setAttribute('stroke', '#6b7280');
            innerCircle.setAttribute('stroke-width', 2);
            svg.appendChild(innerCircle);
            
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', centerX);
            text1.setAttribute('y', centerY - 10);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('fill', '#e5e7eb');
            text1.style.fontWeight = 'bold';
            text1.style.fontSize = '1.25rem';
            text1.textContent = 'Skill Gap';
            svg.appendChild(text1);
            
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('x', centerX);
            text2.setAttribute('y', centerY + 15);
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('fill', '#e5e7eb');
            text2.style.fontWeight = 'bold';
            text2.style.fontSize = '1.25rem';
            text2.textContent = 'Analyzer';
            svg.appendChild(text2);
        }

        // Initialize Discovery Matrix
        initMatrix();

        // ==================== FEEDBACK LOOPS CODE ====================
        let flowNodes = [];
        let flowConnections = [];
        let originalNodes = [];
        let draggedNode = null;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let pulses = [];
        let animationId = null;

        function initFeedbackView() {
            let row = [10, 20, 30, 40, 50, 65, 80];
            let col = [8, 25, 42, 58, 75];

function initFeedbackView() {
            let row = [10, 20, 30, 40, 50, 65, 80];
            let col = [8, 25, 42, 58, 75];

            flowNodes = [
                { id: 2, name: "Better Data Input", x: col[4], y: row[0] },
                { id: 3, name: "Better Performance", x: col[2], y: row[2] },
                { id: 4, name: "Better Recommendations", x: col[2], y: row[1] },
                { id: 5, name: "Better Skills", x: col[0], y: row[2] },
                { id: 6, name: "Fewer Available Resources", x: col[4], y: row[3] },
                { id: 7, name: "Higher Engagement", x: col[1], y: row[1] },
                { id: 8, name: "Improved Accuracy", x: col[3], y: row[0] },
                { id: 9, name: "Improved Analyzer", x: col[4], y: row[1] },
                { id: 10, name: "Inaccurate Data", x: col[1], y: row[0] },
                { id: 11, name: "Less Need for Training", x: col[2], y: row[5] },
                { id: 12, name: "Lesser Improvement", x: col[1], y: row[6] },
                { id: 13, name: "Limited Training", x: col[4], y: row[4] },
                { id: 14, name: "More Data", x: col[0], y: row[0] },
                { id: 15, name: "Investment Demand", x: col[3], y: row[2] },
                { id: 17, name: "More Learning Activity", x: col[1], y: row[3] },
                { id: 18, name: "More Personalization", x: col[0], y: row[1] },
                { id: 19, name: "Motivation", x: col[0], y: row[5] },
                { id: 20, name: "Optimization", x: col[2], y: row[0] },
                { id: 22, name: "Reduced Platform Activity", x: col[2], y: row[6] },
                { id: 23, name: "Skill Gap Decrease", x: col[1], y: row[4] },
                { id: 24, name: "Skill Improvement", x: col[0], y: row[3] },
                { id: 25, name: "Slower Improvement", x: col[3], y: row[4] },
                { id: 26, name: "Stable Skill Level", x: col[1], y: row[5] },
                { id: 27, name: "Too Many Tasks", x: col[2], y: row[4] },
                { id: 28, name: "User Fatigue", x: col[2], y: row[3] },
                { id: 29, name: "Greater Resource Allocation", x: col[4], y: row[2]}
            ];

            flowConnections = [
                { from: 2, to: 4, type: "positive" },
                { from: 3, to: 15, type: "positive" },
                { from: 5, to: 3, type: "positive" },
                { from: 7, to: 14, type: "positive" },
                { from: 7, to: 17, type: "positive" },
                { from: 8, to: 2, type: "positive" },
                { from: 9, to: 4, type: "positive" },
                { from: 10, to: 4, type: "negative" },
                { from: 10, to: 20, type: "positive" },
                { from: 11, to: 22, type: "positive" },
                { from: 12, to: 26, type: "positive" },
                { from: 14, to: 10, type: "positive" },
                { from: 14, to: 18, type: "positive" },
                { from: 17, to: 24, type: "positive" },
                { from: 17, to: 27, type: "positive" },
                { from: 18, to: 7, type: "positive" },
                { from: 20, to: 8, type: "positive" },
                { from: 22, to: 12, type: "positive" },
                { from: 23, to: 11, type: "positive" },
                { from: 24, to: 5, type: "positive" },
                { from: 24, to: 23, type: "positive" },
                { from: 26, to: 19, type: "negative" },
                { from: 27, to: 28, type: "positive" },
                { from: 28, to: 7, type: "negative" },
                { from: 4, to: 7, type: "positive" },
                { from: 7, to: 14, type: "positive" },
                { from: 15, to: 29, type: "positive" },
                {from: 29, to: 9, type: "positive" },
                {from: 29, to: 6, type: "negative" },
                {from: 6, to: 13, type: "negative" },
                {from: 13, to: 25, type: "negative" },
                {from: 25, to: 15, type: "negative" },
                {from: 24, to: 19, type: "positive" },
                {from: 19, to: 17, type: "positive"}
            ];
}

            originalNodes = JSON.parse(JSON.stringify(flowNodes));

            const flowchart = document.getElementById('flowchart');
            const svg = document.getElementById('connections');
            
            initializeNodePositions();
            createFlowNodes();
            drawFlowConnections();
            initPulses();
            createPulseElements();
            animatePulses();
            
            window.addEventListener('resize', () => {
                initializeNodePositions();
                updateNodeElements();
                drawFlowConnections();
            });

            document.getElementById('resetBtn').addEventListener('click', resetView);
            document.getElementById('highlightBtn').addEventListener('click', highlightLoops);
        }

        function initializeNodePositions() {
            const containerWidth = document.getElementById('flowchart').offsetWidth;
            const containerHeight = document.getElementById('flowchart').offsetHeight;
            
            flowNodes.forEach((node, index) => {
                node.actualX = (node.x / 100) * containerWidth;
                node.actualY = (node.y / 100) * containerHeight;
                originalNodes[index].actualX = node.actualX;
                originalNodes[index].actualY = node.actualY;
            });
        }

        function updateNodeElements() {
            flowNodes.forEach(node => {
                const nodeEl = document.querySelector(`[data-flow-id="${node.id}"]`);
                if (nodeEl) {
                    nodeEl.style.left = node.actualX + 'px';
                    nodeEl.style.top = node.actualY + 'px';
                }
            });
        }

        function createFlowNodes() {
            const flowchart = document.getElementById('flowchart');
            
            flowNodes.forEach(node => {
                const div = document.createElement('div');
                div.className = 'flow-node';
                div.textContent = node.name;
                div.dataset.flowId = node.id;
                div.style.zIndex = 2;
                div.style.left = node.actualX + 'px';
                div.style.top = node.actualY + 'px';
                
                div.addEventListener('mousedown', (e) => {
                    isDragging = false;
                    draggedNode = node;
                    offsetX = e.clientX - node.actualX;
                    offsetY = e.clientY - node.actualY;
                    
                    highlightConnections(node.id);
                    div.style.cursor = 'grabbing';
                    e.preventDefault();
                });
                
                flowchart.appendChild(div);
            });

            document.addEventListener('mousemove', (e) => {
                if (draggedNode) {
                    const moveThreshold = 5;
                    const deltaX = Math.abs(e.clientX - (draggedNode.actualX + offsetX));
                    const deltaY = Math.abs(e.clientY - (draggedNode.actualY + offsetY));
                    
                    if (deltaX > moveThreshold || deltaY > moveThreshold) {
                        isDragging = true;
                    }
                    
                    if (isDragging) {
                        draggedNode.actualX = e.clientX - offsetX;
                        draggedNode.actualY = e.clientY - offsetY;
                        
                        const nodeEl = document.querySelector(`[data-flow-id="${draggedNode.id}"]`);
                        nodeEl.style.left = draggedNode.actualX + 'px';
                        nodeEl.style.top = draggedNode.actualY + 'px';
                        
                        drawFlowConnections();
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (draggedNode) {
                    const nodeEl = document.querySelector(`[data-flow-id="${draggedNode.id}"]`);
                    nodeEl.style.cursor = 'grab';
                    
                    resetHighlight();
                    
                    draggedNode = null;
                    isDragging = false;
                }
            });
        }

        function drawFlowConnections() {
            const svg = document.getElementById('connections');
            svg.innerHTML = '';
            
            flowConnections.forEach(conn => {
                const fromNode = flowNodes.find(n => n.id === conn.from);
                const toNode = flowNodes.find(n => n.id === conn.to);
                
                const x1 = fromNode.actualX + 75;
                const y1 = fromNode.actualY + 25;
                const x2 = toNode.actualX + 75;
                const y2 = toNode.actualY + 25;
                
                const dx = x2 - x1;
                const dy = y2 - y1;
                const angle = Math.atan2(dy, dx);
                
                const arrowX = x2 - Math.cos(angle) * 80;
                const arrowY = y2 - Math.sin(angle) * 30;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (x1 + arrowX) / 2;
                const midY = (y1 + arrowY) / 2;
                
                const d = `M ${x1} ${y1} Q ${midX} ${midY} ${arrowX} ${arrowY}`;
                path.setAttribute('d', d);
                path.setAttribute('class', `flow-connection ${conn.type}`);
                path.dataset.from = conn.from;
                path.dataset.to = conn.to;
                
                svg.appendChild(path);
                
                const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const arrowSize = 16;
                const points = [
                    [arrowX, arrowY],
                    [arrowX - arrowSize * Math.cos(angle - Math.PI / 6), arrowY - arrowSize * Math.sin(angle - Math.PI / 6)],
                    [arrowX - arrowSize * Math.cos(angle + Math.PI / 6), arrowY - arrowSize * Math.sin(angle + Math.PI / 6)]
                ];
                arrowHead.setAttribute('points', points.map(p => p.join(',')).join(' '));
                arrowHead.setAttribute('class', `arrow ${conn.type}`);
                arrowHead.dataset.from = conn.from;
                arrowHead.dataset.to = conn.to;
                
                svg.appendChild(arrowHead);
            });
            
            createPulseElements();
        }

        function initPulses() {
            pulses = flowConnections.map((conn, index) => ({
                connection: conn,
                progress: Math.random(),
                speed: 0.005 + Math.random() * 0.003
            }));
        }

        function createPulseElements() {
            const svg = document.getElementById('connections');
            document.querySelectorAll('.pulse').forEach(p => p.remove());
            
            pulses.forEach((pulse, index) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', `pulse ${pulse.connection.type}`);
                circle.setAttribute('r', '6');
                circle.dataset.index = index;
                circle.dataset.from = pulse.connection.from;
                circle.dataset.to = pulse.connection.to;
                svg.appendChild(circle);
            });
        }

        function animatePulses() {
            pulses.forEach((pulse, index) => {
                pulse.progress += pulse.speed;
                if (pulse.progress > 1) {
                    pulse.progress = 0;
                }

                const fromNode = flowNodes.find(n => n.id === pulse.connection.from);
                const toNode = flowNodes.find(n => n.id === pulse.connection.to);

                if (fromNode && toNode) {
                    const x1 = fromNode.actualX + 75;
                    const y1 = fromNode.actualY + 25;
                    const x2 = toNode.actualX + 75;
                    const y2 = toNode.actualY + 25;
                    
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const angle = Math.atan2(dy, dx);
                    
                    const arrowX = x2 - Math.cos(angle) * 80;
                    const arrowY = y2 - Math.sin(angle) * 30;

                    const t = pulse.progress;
                    const midX = (x1 + arrowX) / 2;
                    const midY = (y1 + arrowY) / 2;

                    const x = (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * midX + t * t * arrowX;
                    const y = (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * midY + t * t * arrowY;

                    const circle = document.querySelector(`.pulse[data-index="${index}"]`);
                    if (circle) {
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                    }
                }
            });

            animationId = requestAnimationFrame(animatePulses);
        }

        function highlightConnections(nodeId) {
            const connectedNodes = new Set();
            connectedNodes.add(nodeId);
            
            flowConnections.forEach(conn => {
                if (conn.from === nodeId) connectedNodes.add(conn.to);
                if (conn.to === nodeId) connectedNodes.add(conn.from);
            });
            
            document.querySelectorAll('.flow-node').forEach(n => {
                const id = parseInt(n.dataset.flowId);
                if (connectedNodes.has(id)) {
                    n.classList.add('active');
                } else {
                    n.classList.add('faded');
                }
            });
            
            document.querySelectorAll('.flow-connection, .arrow').forEach(el => {
                const from = parseInt(el.dataset.from);
                const to = parseInt(el.dataset.to);
                
                if (from === nodeId || to === nodeId) {
                    el.classList.add('highlight');
                } else {
                    el.classList.add('faded');
                }
            });

            document.querySelectorAll('.pulse').forEach(pulse => {
                const from = parseInt(pulse.dataset.from);
                const to = parseInt(pulse.dataset.to);
                
                if (from === nodeId || to === nodeId) {
                    pulse.classList.remove('hidden');
                } else {
                    pulse.classList.add('hidden');
                }
            });
        }

        function resetHighlight() {
            document.querySelectorAll('.flow-node').forEach(n => {
                n.classList.remove('active', 'faded');
            });
            document.querySelectorAll('.flow-connection, .arrow').forEach(el => {
                el.classList.remove('highlight', 'faded');
            });
            
            document.querySelectorAll('.pulse').forEach(pulse => {
                pulse.classList.remove('hidden');
            });
        }

        function resetView() {
            flowNodes.forEach((node, index) => {
                node.actualX = originalNodes[index].actualX;
                node.actualY = originalNodes[index].actualY;
                const nodeEl = document.querySelector(`[data-flow-id="${node.id}"]`);
                nodeEl.style.left = node.actualX + 'px';
                nodeEl.style.top = node.actualY + 'px';
            });
            
            resetHighlight();
            drawFlowConnections();
        }

        function highlightLoops() {
            document.querySelectorAll('.flow-connection, .arrow').forEach(el => {
                el.classList.add('highlight');
            });
            
            setTimeout(resetHighlight, 3000);
        }
    </script>
</body>
</html>
